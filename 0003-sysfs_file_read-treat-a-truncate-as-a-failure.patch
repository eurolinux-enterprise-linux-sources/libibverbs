From a7a73a8c1b39362f1701256bc772d82847832f9c Mon Sep 17 00:00:00 2001
Message-Id: <a7a73a8c1b39362f1701256bc772d82847832f9c.1443021080.git.dledford@redhat.com>
In-Reply-To: <252749ced9cacc991f116ebc99d4f5e4e15e55cc.1443021080.git.dledford@redhat.com>
References: <252749ced9cacc991f116ebc99d4f5e4e15e55cc.1443021080.git.dledford@redhat.com>
From: Doug Ledford <dledford@redhat.com>
Date: Wed, 29 Jul 2015 11:58:57 -0400
Subject: [PATCH libibverbs 03/12] sysfs_file_read: treat a truncate as a
 failure
To: linux-rdma@vger.kernel.org

Coverity found issue.  When we read a sysfs file and the length of the
read exactly matches our buffer and we don't have a newline to replace
with a null termination, we either have to truncate the result, or fail
to null terminate.  Either way, we will not get the desired behavior, so
in that case, fail the read entirely.

Signed-off-by: Doug Ledford <dledford@redhat.com>
---
 src/sysfs.c | 15 +++++++++++++--
 1 file changed, 13 insertions(+), 2 deletions(-)

diff --git a/src/sysfs.c b/src/sysfs.c
index e031631cfd64..0b6ad1e8cc9e 100644
--- a/src/sysfs.c
+++ b/src/sysfs.c
@@ -96,8 +96,19 @@ int ibv_read_sysfs_file(const char *dir, const char *file,
 	close(fd);
 	free(path);
 
-	if (len > 0 && buf[len - 1] == '\n')
-		buf[--len] = '\0';
+	if (len > 0) {
+		if (buf[len - 1] == '\n')
+			buf[--len] = '\0';
+		else if (len < size)
+			buf[len] = '\0';
+		else
+			/* We would have to truncate the contents to NULL
+			 * terminate, so we are going to fail no matter
+			 * what we do, either right now or later when
+			 * we pass around an unterminated string.  Fail now.
+			 */
+			return -1;
+	}
 
 	return len;
 }
-- 
2.4.3

